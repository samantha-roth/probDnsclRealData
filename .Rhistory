load(paste0(folder,"/random/seed",seed,"/BASS_size"))
sizes_R[s]<- BASS_size
}
if(seed==31){
load(paste0(folder,"/v2/BASS_size"))
sizes_MMU[s]<- BASS_size
load(paste0(folder,"/maxminall/BASS_size"))
sizes_MMA[s]<- BASS_size
load(paste0(folder,"/maxuncertainty/BASS_size"))
sizes_MPU[s]<- BASS_size
load(paste0(folder,"/random/BASS_size"))
sizes_R[s]<- BASS_size
}
}
save(sizes_MMU,file=paste0(saveto,"/sizes_MMU"))
save(sizes_R,file=paste0(saveto,"/sizes_R"))
save(sizes_MMA,file=paste0(saveto,"/sizes_MMA"))
save(sizes_MPU,file=paste0(saveto,"/sizes_MPU"))
mean(sizes_MMU)
mean(sizes_MMA)
mean(sizes_MPU)
mean(sizes_R)
library(plot.matrix)
library(RColorBrewer)
library(ggplot2)
library(gridExtra)
library(grid)
df <- data.frame(
Method = rep(c("A+BASS (SA)", "A+BASS (MM)", "A+BASS (PU)", "BASS"), each = n_seeds),
Size = c(sizes_MMU, sizes_MMA, sizes_MPU, sizes_R)
)
# Create the plot
g<- ggplot(df, aes(x = Method, y = Size, color=Method)) +
geom_point(position = position_dodge(width = 0), alpha = 0.7, size=3) +
scale_color_manual(values= c("A+BASS (SA)"= "purple", "A+BASS (MM)"="violet", "A+BASS (PU)"= "turquoise","BASS"="blue")) +
labs(title= NULL,
x = NULL,
y = "Number of model runs") +
theme_minimal()+
theme(plot.title = element_text(size=18),
axis.title = element_text(size=18),
axis.text = element_text(size=16),
#panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position="none",
axis.text.x = element_text(angle = 45, hjust = 1))
plot_folder <- paste0("./plots/",d,"D/",c,"cores") #set folder depending on d and c
if (!dir.exists(plot_folder)) dir.create(file.path(plot_folder), recursive = TRUE)
# Display the plot
filename<- paste0(plot_folder,"plots/plotMatrix_MMU_MMA_MPU_R.jpeg")
jpeg(file = filename,width = 600,height=800,type="cairo")
print(g)
dev.off()
print(g)
rm(list=ls())
graphics.off()
library(terra)
library(nimble)
library(MCMCvis)
setwd("/Users/f007f8t/Documents/GitHub/probDnsclRealData")
#load 10m flood projection
run10m<- rast("data/Outputs10m/Run_1.asc")
#load all 10m grid cell centroids
load("data/coords.10m.RData")
#load 10m inds we want to focus on
load("data/goodinds_aboveriver")
locations_c<- coords.10m[goodinds_aboveriver,]
z_c<- terra::values(run10m)[goodinds_aboveriver]
################################################################################
###############################MOST BASIC VERSION###############################
################################################################################
################################################################################
#####################CORRECT with SPATIAL CORRELATION###########################
################################################################################
model_c1 <- nimbleCode({
# likelihood
#zero-mean, unit variance spatial processes
z_c[1:N_c] ~ dmnorm(mu_c[1:N_c], cov = Sigma_c[1:N_c, 1:N_c])
mu_c[1:N_c] <- G_c[1:N_c, 1:N_b] %*% y_b[1:N_b]
# Build spatial covariance matrix with exponential covariance function
for(i in 1:N_c) {
for(j in 1:N_c) {
Sigma_c[i, j] <- tau2_c * isdiag[i, j]+ exp(-phi* dist[i, j])
}
}
for(k in 1:N_b) {
y_b[k] ~ dnorm(0, sd = 5) #the five 5m cells that correspond to HWM locations
}
phi ~ dunif(0.01, 10)
tau2_c ~ dinvgamma(shape = 2, scale = 1)
})
# #Define discrete uniform distribution for phi
# max_phi<- 10
# phi_vals <- seq(1, max_phi, by = 1)
# n_phi <- length(phi_vals)
# prob_phi <- rep(1/n_phi, n_phi)
N_c = length(z_c)
N_b= 4*N_c
isdiag <- diag(N_c)
zeros <- rep(0, N_c)
#generate random initial values for all parameters
initial.values.function_c1 <- function() {
return(list(y_b = rnorm(N_b, mean=0, sd=5),
tau2_c= rinvgamma(1, shape= 2, rate=1),
phi = runif(1, 0.01, 10)))
}
# Calculate distance matrix using manhattan distance because it's an exp cov function
dist_matrix_manhattan <- as.matrix(dist(locations_c,method= "manhattan"))
G_c<- matrix(0, nrow=length(z_c), ncol= 4*length(z_c))
for(i in 1:length(z_c)){
G_c[i,((i-1)*4+1):(i*4)]<- 1
}
my.constants_c1 <- list(N_c = N_c,
N_b = N_b,
dist = dist_matrix_manhattan,
G_c = G_c,
isdiag = isdiag)
# Data
my.data_c1 <- list(
z_c = z_c
)
parameters.to.save_c1 <- c("tau2_c", "phi", "y_b")
# MCMC settings
set.seed(666)
n.iter <- 4100
n.burnin <- 100
n.chains <- 3
start<- proc.time()
# Fit model
mcmc.output_c1 <- nimbleMCMC(code = model_c1,
data = my.data_c1,
constants = my.constants_c1,
inits = initial.values.function_c1,
monitors = parameters.to.save_c1,
niter = n.iter,
nburnin = n.burnin,
nchains = n.chains)
rm(list=ls())
graphics.off()
library(terra)
library(nimble)
library(MCMCvis)
setwd("/Users/f007f8t/Documents/GitHub/probDnsclRealData")
#load 10m flood projection
run10m<- rast("data/Outputs10m/Run_1.asc")
#load all 10m grid cell centroids
load("data/coords.10m.RData")
#load 10m inds we want to focus on
load("data/goodinds_aboveriver")
locations_c<- coords.10m[goodinds_aboveriver,]
z_c<- terra::values(run10m)[goodinds_aboveriver]
################################################################################
############################NO SPATIAL CORRELATION##############################
################################################################################
model_c0 <- nimbleCode({
# likelihood
#zero-mean, unit variance spatial processes
z_c[1:N_c] ~ dmnorm(mu_c[1:N_c], cov = Sigma_c[1:N_c, 1:N_c])
mu_c[1:N_c] <- G_c[1:N_c, 1:N_b] %*% y_b[1:N_b]
# Build spatial covariance matrix with exponential covariance function
for(i in 1:N_c) {
for(j in 1:N_c) {
Sigma_c[i, j] <- tau2_c * isdiag[i, j]
}
}
for(k in 1:N_b) {
y_b[k] ~ dnorm(0, sd = 5) #the five 5m cells that correspond to HWM locations
}
tau2_c ~ dinvgamma(shape = 2, scale = 1)
})
N_c = length(z_c)
N_b= 4*N_c
isdiag <- diag(N_c)
#generate random initial values for all parameters
initial.values.function_c0 <- function() {
return(list(y_b = rnorm(N_b, mean=0, sd=5),
tau2_c= rinvgamma(1, shape= 2, rate=1)))
}
G_c<- matrix(0, nrow=length(z_c), ncol= 4*length(z_c))
for(i in 1:length(z_c)){
G_c[i,((i-1)*4+1):(i*4)]<- 1/4
}
my.constants_c0 <- list(N_c = N_c,
N_b = N_b,
G_c = G_c,
isdiag = isdiag)
# Data
my.data_c0 <- list(
z_c = z_c
)
parameters.to.save_c0 <- c("tau2_c", "y_b")
# MCMC settings
set.seed(666)
n.iter <- 4100
n.burnin <- 100
n.chains <- 3
start<- proc.time()
# Fit model
mcmc.output_c0 <- nimbleMCMC(code = model_c0,
data = my.data_c0,
constants = my.constants_c0,
inits = initial.values.function_c0,
monitors = parameters.to.save_c0,
niter = n.iter,
nburnin = n.burnin,
nchains = n.chains)
rm(list=ls())
graphics.off()
library(terra)
library(nimble)
library(MCMCvis)
setwd("/Users/f007f8t/Documents/GitHub/probDnsclRealData")
#load 10m flood projection
run10m<- rast("data/Outputs10m/Run_1.asc")
#load all 10m grid cell centroids
load("data/coords.10m.RData")
#load 10m inds we want to focus on
load("data/goodinds_aboveriver")
locations_c<- coords.10m[goodinds_aboveriver,]
z_c<- terra::values(run10m)[goodinds_aboveriver]
################################################################################
############################NO SPATIAL CORRELATION##############################
################################################################################
model_c0 <- nimbleCode({
# likelihood
for(i in 1:N_c){
z_c[i] ~ dnorm(mu_c[i],var= tau2_c)
}
# #zero-mean, unit variance spatial processes
# z_c[1:N_c] ~ dmnorm(mu_c[1:N_c], cov = Sigma_c[1:N_c, 1:N_c])
mu_c[1:N_c] <- G_c[1:N_c, 1:N_b] %*% y_b[1:N_b]
# # Build spatial covariance matrix with exponential covariance function
# for(i in 1:N_c) {
#   for(j in 1:N_c) {
#     Sigma_c[i, j] <- tau2_c * isdiag[i, j]
#   }
# }
for(k in 1:N_b) {
y_b[k] ~ dnorm(0, sd = 5) #the five 5m cells that correspond to HWM locations
}
tau2_c ~ dinvgamma(shape = 2, scale = 1)
})
N_c = length(z_c)
N_b= 4*N_c
isdiag <- diag(N_c)
#generate random initial values for all parameters
initial.values.function_c0 <- function() {
return(list(y_b = rnorm(N_b, mean=0, sd=5),
tau2_c= rinvgamma(1, shape= 2, rate=1)))
}
G_c<- matrix(0, nrow=length(z_c), ncol= 4*length(z_c))
for(i in 1:length(z_c)){
G_c[i,((i-1)*4+1):(i*4)]<- 1/4
}
my.constants_c0 <- list(N_c = N_c,
N_b = N_b,
G_c = G_c,
isdiag = isdiag)
# Data
my.data_c0 <- list(
z_c = z_c
)
parameters.to.save_c0 <- c("tau2_c", "y_b")
# MCMC settings
set.seed(666)
n.iter <- 4100
n.burnin <- 100
n.chains <- 3
start<- proc.time()
# Fit model
mcmc.output_c0 <- nimbleMCMC(code = model_c0,
data = my.data_c0,
constants = my.constants_c0,
inits = initial.values.function_c0,
monitors = parameters.to.save_c0,
niter = n.iter,
nburnin = n.burnin,
nchains = n.chains)
end<- proc.time()
mcmc_time_c0<- as.numeric(end[3]-start[3])
save(mcmc_time_c0,file="data/wb_onlyZc_mcmc_time_c0")
save(mcmc_output_c0,file="data/wb_onlyZc_mcmc_output_c0")
save(mcmc.output_c0,file="data/wb_onlyZc_mcmc_output_c0")
mcmc_time_c0
mcmc_time_c0/60
mcmc_time_c0/60/60
rm(list=ls())
graphics.off()
library(terra)
library(nimble)
library(MCMCvis)
setwd("/Users/f007f8t/Documents/GitHub/probDnsclRealData")
#load 10m flood projection
run10m<- rast("data/Outputs10m/Run_1.asc")
#load all 10m grid cell centroids
load("data/coords.10m.RData")
#load 10m inds we want to focus on
load("data/goodinds_aboveriver")
locations_c<- coords.10m[goodinds_aboveriver,]
z_c<- terra::values(run10m)[goodinds_aboveriver]
################################################################################
############################NO SPATIAL CORRELATION##############################
################################################################################
model_c0 <- nimbleCode({
# likelihood
for(i in 1:N_c){
z_c[i] ~ dnorm(mu_c[i],var= tau2_c)
}
# #zero-mean, unit variance spatial processes
# z_c[1:N_c] ~ dmnorm(mu_c[1:N_c], cov = Sigma_c[1:N_c, 1:N_c])
mu_c[1:N_c] <- G_c[1:N_c, 1:N_b] %*% y_b[1:N_b]
# # Build spatial covariance matrix with exponential covariance function
# for(i in 1:N_c) {
#   for(j in 1:N_c) {
#     Sigma_c[i, j] <- tau2_c * isdiag[i, j]
#   }
# }
for(k in 1:N_b) {
y_b[k] ~ dnorm(0, sd = 5) #the five 5m cells that correspond to HWM locations
}
tau2_c ~ dinvgamma(shape = 2, scale = 1)
})
N_c = length(z_c)
N_b= 4*N_c
isdiag <- diag(N_c)
#generate random initial values for all parameters
initial.values.function_c0 <- function() {
return(list(y_b = rnorm(N_b, mean=0, sd=5),
tau2_c= rinvgamma(1, shape= 2, rate=1)))
}
G_c<- matrix(0, nrow=length(z_c), ncol= 4*length(z_c))
for(i in 1:length(z_c)){
G_c[i,((i-1)*4+1):(i*4)]<- 1/4
}
my.constants_c0 <- list(N_c = N_c,
N_b = N_b,
G_c = G_c,
isdiag = isdiag)
# Data
my.data_c0 <- list(
z_c = z_c
)
parameters.to.save_c0 <- c("tau2_c", "y_b")
# MCMC settings
set.seed(666)
n.iter <- 4100
n.burnin <- 100
n.chains <- 1
start<- proc.time()
# Fit model
mcmc.output_c0 <- nimbleMCMC(code = model_c0,
data = my.data_c0,
constants = my.constants_c0,
inits = initial.values.function_c0,
monitors = parameters.to.save_c0,
niter = n.iter,
nburnin = n.burnin,
nchains = n.chains)
end<- proc.time()
mcmc_time_c0<- as.numeric(end[3]-start[3])
save(mcmc_time_c0,file="data/wb_onlyZc_mcmc_time_c0")
save(mcmc.output_c0,file="data/wb_onlyZc_mcmc_output_c0")
mcmc_time_c0/60
MCMCtrace(object = mcmc.output_c0,
pdf = FALSE,
ind = TRUE,
params = "tau2_c")
dim(mcmc.output_c0)
2748/48
2748/12
y_b_mat_c0<- mcmc.output_c0[,2:ncol(mcmc.output_c0)]
set.seed(10)
rand_inds<- sample(1:ncol(y_b_mat_c0),10)
for(i in 1:length(rand_inds)){
print(plot(1:nrow(y_b_mat_c0),y_b_mat_c0[,rand_inds[i]]))
}
for(i in 1:length(rand_inds)){
print(plot(1:nrow(y_b_mat_c0),y_b_mat_c0[,rand_inds[i]],type="l"))
}
View(G_c)
rm(list=ls())
graphics.off()
library(terra)
library(nimble)
library(MCMCvis)
setwd("/Users/f007f8t/Documents/GitHub/probDnsclRealData")
#load 10m flood projection
run10m<- rast("data/Outputs10m/Run_1.asc")
#load all 10m grid cell centroids
load("data/coords.10m.RData")
#load 10m inds we want to focus on
load("data/goodinds_aboveriver")
locations_c<- coords.10m[goodinds_aboveriver,]
z_c<- terra::values(run10m)[goodinds_aboveriver]
load("data/wb_onlyZc_mcmc_output_c0")
rm(list=ls())
graphics.off()
library(terra)
library(nimble)
library(MCMCvis)
setwd("/Volumes/RothS/probDnsclRealData")
getwd()
rm(list=ls())
graphics.off()
library(terra)
library(nimble)
library(MCMCvis)
setwd("/Volumes/RothS/probDnsclRealData")
#check mcmc output
rm(list=ls())
graphics.off()
library(terra)
library(nimble)
# library(MCMCvis)
setwd("/Volumes/RothS/probDnsclRealData")
# setwd("/dartfs/rc/lab/R/RothS/probDnsclRealData")
load("data/wb_onlyZc_mcmc.time_c1")
load("data/wb_onlyZc_mcmc.output_c1")
print(paste0("time in hours: ",mcmc.time_c1/(60^2)))
library(mcmcse)
library(mcmcse)
?ess
dim(mcmc.output_c1)
for( i in 1:7){
print(ess(mcmc.output_c1[,i]))
}
as.numeric(multiESS(mcmc.output_c1))
library(geostats)  # For semivariogram computation
setwd("/Users/f007f8t/Documents/GitHub/probDnsclRealData")
#load the high water marks
load("data/HWMsdf.RData")
HWMlocs<- as.matrix(HWMs.df[,c("x","y")]); HWMlocs<- HWMlocs[1:5,]
obs<- HWMs.df$height[1:5]
#load the 10m res water surface heights
load("data/wsh.10m_HWMlocs")
################################################################################
#consider the difference between the observations and the 10m flood heights
resid<- obs-wsh.10m
sv_res_spher<- geostats::semivariogram(x=HWMlocs[,"x"],y=HWMlocs[,"y"],z=resid, model= "spherical", fit=TRUE, nb= 4)
sv_res_exp<- geostats::semivariogram(x=HWMlocs[,"x"],y=HWMlocs[,"y"],z=resid, model= "exponential", fit=TRUE, nb= 4)
sv_res_gaus<- geostats::semivariogram(x=HWMlocs[,"x"],y=HWMlocs[,"y"],z=resid, model= "gaussian", fit=TRUE, nb= 4)
sv_res_exp_pars<- sv_res_exp$snr
sv_res_gaus_pars<- sv_res_gaus$snr
sv_res_spher_pars<- sv_res_spher$snr
save(sv_res_exp_pars,file="data/sv_res_exp_pars")
save(sv_res_gaus_pars,file="data/sv_res_gaus_pars")
save(sv_res_spher_pars,file="data/sv_res_spher_pars")
load("data/mcmc.output1_thinned")
SLR_mcmc_pred_func<- function(step){
return(wsh.10m*beta1_thin[step] + beta0_thin[step])
}
#get downscaled values using the Bayesian SLR model
downscale_vals<- matrix(NA, nrow=length(thin_inds), ncol= length(wsh.10m))
for(i in 1:length(thin_inds)){
downscale_vals[i,]<- SLR_mcmc_pred_func(i)
}
mean_downscale_vals<- apply(downscale_vals,2,mean)
qs_downscale_vals<- apply(downscale_vals,2,function(x) quantile(x,probs= c(0.025, 0.5, 0.975)))
SLR_resids<- obs-mean_downscale_vals
save(SLR_resids,file="data/BayesianSLR_resids")
################################################################################
# #now check the residuals for the SLR predictions when SLR is fit via MLE
#
# SLR_fit<- lm(obs~wsh.10m) #to inform priors for beta0 and beta1
# mse<- mean(SLR_fit$residuals^2) #to inform tau2
#
# SLR_resids<- SLR_fit$residuals
# #results are about the same as when we use SLR fit via MCMC, unsurprisingly
################################################################################
sv_SLR_spher<- geostats::semivariogram(x=HWMlocs[,"x"],y=HWMlocs[,"y"],z=SLR_resids, model= "spherical", fit=TRUE, nb= 4)
sv_SLR_exp<- geostats::semivariogram(x=HWMlocs[,"x"],y=HWMlocs[,"y"],z=SLR_resids, model= "exponential", fit=TRUE, nb= 4)
sv_SLR_gaus<- geostats::semivariogram(x=HWMlocs[,"x"],y=HWMlocs[,"y"],z=SLR_resids, model= "gaussian", fit=TRUE, nb= 4)
rm(list=ls())
graphics.off()
setwd("/Users/f007f8t/Documents/GitHub/probDnsclRealData")
#setwd("/Users/f007f8t/Documents/GitHub/probDnsclRealData")
library(terra)
library(ggplot2)
#load the bilinearly interpolated AND SHIFTED 10m projections at the HWM locations
load("data/downscale10mto5mAtHWMs.RData")
downscale10mAtHWMs<- downscale10m; rm(downscale10m)
#load the high water marks
load("data/HWMsdf.RData")
HWMlocs<- as.matrix(HWMs.df[,c("x","y")]); HWMlocs<- HWMlocs[1:5,]
obs<- HWMs.df$height[1:5]
#get 5m preds at HWM locations
run5m<- rast("data/Outputs5m/Run_1.asc")
preds5matHWMs<- c(as.matrix(extract(run5m,HWMlocs)))
run10m<- rast("data/Outputs10m/Run_1.asc")
preds10matHWMs<- c(as.matrix(extract(run10m,HWMlocs)))
resid<- obs-preds10matHWMs
res_10m<- obs-preds10matHWMs
#load the residuals from regressing the high water marks on the low resolution flood heights
load("data/BayesianSLR_resids")
preds_obs_locs.df<- data.frame("obs"=obs,
"preds10m"=preds10matHWMs,
"preds5m"=preds5matHWMs,
"downscale10mto5m"=downscale10mAtHWMs,
"SLR_resids"= SLR_resids,
"res_10m"= res_10m,
"x"=HWMlocs[,"x"],
"y"=HWMlocs[,"y"])
filename<- paste0("plots/Obs-10mInSpace.jpeg")
jpeg(file = filename,width = 700,height=450)
print(ggplot(data=preds_obs_locs.df,aes(x=x,y=y,color=res_10m))+
geom_point(size=5) + theme_bw() + labs(color= "residual (m)") +
theme(plot.title = element_text(size=24),
axis.title = element_text(size=24),
axis.text = element_text(size = 20),
legend.text= element_text(size=24),
legend.title= element_text(size=24)))
dev.off()
